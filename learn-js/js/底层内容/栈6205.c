int foo(int n) {
  int a = 8       // pushsp 8
  int b = 9       // pushsp 9

  int c = a + b
  // ldy #$02
  // lad (sp), y
  // DEY
  // ADC (sp), y
  // JSR PUSHAsp

  int d = c + A
  // ldy #$01
  // lda (sp), y
  // DEY
  // dey
  // ADC (sp), y
  // JSR PUSHAsp

  return c
}
// 

//汇编语言，不确定长度
int foo() {
  int a = 8       // pushsp 8
  int b = 9       // pushsp 9

  int ary = new Array(Math.random()) // 动态数组，
  
  n = 50  // 50个字节（byte）
  int * a = alloc(n)

  // 在c 中
  // 占用空间确定的内容（静态分配的空间）放在栈内存中， 占用内存空间不确定的内容(或动态分配的空间）放在堆内存中
  //动态长度（如长度不确定的数组），不能存储在栈中，会给予固定长度的空间存储存储其存放的地址（位置信息）
  // 动态长度，会存放于另外的区域（这个区域不是栈类型，无序的）

  // 对于c编写的程序 栈记录了，函数的形参，函数的临时变量，函数的调用关系

  // 还有一段 堆 区域。而动态数组则存放于此，而数组的存放在堆（内存空间）中的起始地址（包括，这个动态数组的长度，需要零一变量记录）被存放于栈的固定空间中

  // 动态内存分配 ，申请空间（memalloc（）函数memory allocate），释放空间 （free（）函数）
  // 当启用一个函数的时候，会分配一个空的堆内存，申请空间函数和释放空间函数用于维护该堆
  // c 语言中，申请多少堆内存，需要自己写
  // 栈内存则由编译器自动读取，申请，释放


  // 在 js 语言中 
  /*
  由于闭包的原因，不考虑栈内存。（可能不考虑栈内存，或者也可以将闭包理解为存放于堆里面的一个不确定空间大小的变量）
  但是，函数间的调用关系，（即调用栈）还是存在的，需要栈内存，但是调用时的变量参数可能还在。
  堆内存（heap） 要考虑。 数组，对象，字符串等 不确定大小的空间
  */
  

  /* 编译型语言 c c++ rust （直接编译到机器码的程序） 源代码将转换汇编然后转换为机器码 由cpu 直接执行
    c 语言编写的代码可以在一个裸机上运行，而不需要操作系统
    Java 介于两者之间
     解释型语言 js python
     c++编写的浏览器内部的js运行程序，被称为解释器，（虚拟机）因为不是一个真正的代码
     js语言 绝大部分时候不编译为机器码（Google 的 v8  可以现场编译js）

    node v8（c++） libuv（c）

     使用js 用其他语言写出一个虚拟机，然后用虚拟机(vm，其复杂度远高于cpu)运行js 
  */ 
  /*
  *java   字节码   Jvm     （.jar 格式）字节码 已经是 jvm指令，不需要任何的编译。（可以调用jvm 中的函数库）
   c       机器码   
  */

  int c = a + b
  
  // ldy #$02
  // lad (sp), y
  // DEY
  // ADC (sp), y
  // JSR PUSHAsp

  int d = c + A
  // ldy #$01
  // lda (sp), y
  // DEY
  // dey
  // ADC (sp), y
  // JSR PUSHAsp

  return c
}